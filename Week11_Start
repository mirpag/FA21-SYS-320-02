# Running processes and the path for each process
Get-Process | Select-Object ProcessName, Path

# all registered services and the path to the executable controlling the service
Get-WmiObject -Class Win32_Service | Select-Object name, Path

# all tcp network sockets
Get-NetTCPConnection

# all user account information (use wmi)
Get-WmiObject -Class Win32_UserAccount | Select *

#all network adapter configuration information
Get-WmiObject -Class Win32_NetworkAdapterConfiguration


# Use Powershell cmdlets to save 4 other artifacts that would be useful in an incident but only use Powershell cmdlets.  
# In your code comment, explain why you selected those four cmdlets and the value it would provide for an incident investigation.
https://www.hackingarticles.in/incident-response-windows-cheatsheet/

# File share permissions
Get-SmbShare

# Firewall Settings
netsh advfirewaall show currentprofile

# Create a prompt that asks the user for the location of where to save the results for the commands above.

# Select a way to use at least one function within your code.

# Find the Powershell cmdlet that can create a 'FileHash' of the resulting CSV files,
# create a checksum for each one, and save the results to a file within the results directory.  
# The file containing checksums should have the filename and the corresponding checksum.
Get-FileHash -Path "PathHere"


# Use the Powershell cmdlet Compress-Archive to zip the directory where the results are stored (ensure it has a .zip file extension).  
# NOTE: You will need to save the zip file outside of the directory where you store the results from the commands above.  
# Otherwise, you will receive an error because as the zip file is being created, it is open, and has a file lock.  You can't zip an open file on Windows.

# Create a checksum of the zipped file and save it to a file.

# Record the screen of the program running and check that each file has the **expected** results.

